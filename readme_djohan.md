# Project 1 Readme Team djohan

| 1 | Team Name:djohan |
| :---: | ----- |
| 2 | Team members names and netids: Daniel Johan, djohan |
| 3 | Overall project attempted, with sub-projects: Knapsack Problem \- An equivalent of DumbSAT for a solver that returns a coin combination that works |
| 4 | Overall success of the project: Successful |
| 5 | Approximately total time (in hours) to complete: 30 hours |
| 6 | Link to github repository: [https://github.com/djohan12/TOC\_project01\_djohan](https://github.com/djohan12/TOC_project01_djohan) |
| 7 | List of included files (if you have many files of a certain type, such as test files of different sizes, list just the folder): (Add more rows as necessary). Add more rows as necessary. File/folder Name File Contents and Use Code Files coinsGenerator\_djohan.py Python script that generates a random target, a random set of coin values, and a random capacity of coins that can be put into the knapsack. For example if the capacity is set to 4, you can only make a combination of coins consisting of at most 4 coins. knapsackCSVGenerator\_djohan.py Takes the input file from the coinsGenerator function and computes the runtime and combination of coins that meets the constraints specified in each scenario. The output is stored in a csv file that the user can specify. knapsackSolverTest\_djohan.py Testing script to see if the input from a tester file matches the expected outcome. If the program determines that it’s possible to create a solution from the given parameters, it checks if there was a possible combination from the tester file, and returns true if there was. If there isn’t a possible combination, it just checks that the output combination is empty or Null. Test Files tester\_djohan.txt The tester file consists of 30 test scenarios with 10 of each size problem. Each line in the tester file represents a test case where its parameters are separated by colons and formatted like this: \[Target: Capacity:Coin Values:Possible Combination (if there isn’t a possible combination it is set to 0)\]. When the tester runs, it sees if it can form a proper combination based on the first three parameters, and if it is possible, it double checks that the sum of the combination is equal to the target. Otherwise if the combination in the test scenario is None, it checks if the combination created is also Null. knapsackSolverData\_djohan.txt/knapsackSolverOutput\_djohan.csv These were early tests to see how well my CSV generator worked. For these, I ran the coin generator to make an input of 500 small, medium, and large cases, and ran that file through the knapsack solver to see if it produced a proper csv that recorded the input parameters, the time it took to run, and the combination if it was possible. ProjectInput\_djohan.txt This is the final input file that I used when collecting the time data. It consists of about 5000 possible input cases and then goes through the CSV generator to determine whether it is possible to create a combination of coins and record the amount of time it took to compute the combination. Output Files ProjectData\_djohan.csv Output file of running knapsackCSVGenerator on the ProjectInput\_djohan.txt file (Note: Some of the values in the input file got overwritten because I forgot to set the write flag to append instead of write, so that’s why the number of inputs doesn’t line up with the number of outputs). Plots (as needed) KnapsackPlots\&Analysis\_djohan.pdf 4 page pdf encompassing the data analysis process and patterns found in the data as well as 6 plots of the data. The graphs show the three different independent variables(Target size, Knapsack Capacity, and Number of Different Coins), and each of these variables has two graphs showing the worst case scenario and the overall data.  |
| 8 | Programming languages used, and associated libraries:  The entire project was implemented in python with the time, random, csv, string, and sys libraries for the main part of the project, and argparse, random, datetime, and textwrap for the coinsGenerator function. |
| 9 | Key data structures (for each sub-project):  The main data structures in the project are the txt files which reads in values from the randomizer for each problem, the csv file which outputs the possible solution and time for each problem. In the main code file, I implemented arrays to keep track of the combinations that I’ve tried and a dictionary to store the working combination with their respective case scenarios. Additionally, I used a dictionary to store the values that I wanted to print to the csv file in the csv generator function |
| 10 | General operation of code (for each subproject): To create an input file:  python3 coinsGenerator\_djohan.py –size n –file input\_file Tester script: python3 knapsackSolverTest-djohan.py \< tester\_file To generate the output csv file from the input file:  python3 knapsackCSVGenerator\_djohan.py \< input\_file \> output\_file |
| 11 | What test cases you used/added, why you used them, what did they tell you about the correctness of your code. I implemented about 30 test cases. Most of them were from random values that I got from a random number generator and calculated the possible combination by hand in order to see how robust my code was against large test numbers. I also added a couple cases where there were no possible combinations under the given constraints to make sure that my program wasn’t giving incorrect results. I lowered the capacity so that it’d be impossible to make a combination with such few coins to prove that even though the coins could make the target value, the capacity constraint is being implemented correctly, |
| 12 | How you managed the code development: I did all of the code development and my general thought process was making a simple input file with coins and a target and see if I could implement the knapsack problem for this one specific case. Once I knew that it worked, I then took the coin generator from Canvas and made some modifications to adjust the maximum range of target values and added a capacity variable to limit the number of coins that could be put into the knapsack. I created input files with multiple cases to see if I was printing out correct results with larger data sets. After that, I began working on taking the input file and seeing if I could output it into a csv file, so I created the csv generator python script that built off of the first script I made. Once I was satisfied I ran large amounts of simulations (about 5000 cases) and analyzed the data in Google Sheets. |
| 13 | Detailed discussion of results: Overall, I am very satisfied with the results of the project. All of my code worked the way I intended; however the computation was relatively slow due to how large the data sets came out to be. Despite that, my code was able to produce a large quantity of data. Once I graphed the data, I had the desired outcome where the graph showed that the time to find the working combinations was increasing for each increase in capacity of the number of different coin values. However, I did have one issue with the data. Because I was increasing the capacity and variety of coins, the likelihood that there wouldn’t be a possible combination decreased since the program had more subsets of possible coin combinations to work with and compute. Because of this the majority of the data covering the worst case scenario centered around the smaller and medium sized problems, and not as much in the larger sized problems. However, the graph I produced from my data showed a very strong exponential relationship between size and time with a correlation coefficient of around .94. Since I had hundreds of data points with a strong correlation, it’s very reasonable to conclude that based on the trendline, combinations with larger coin varieties and capacities would’ve followed that pattern, so they also would’ve had exponentially large computing times as well |
| 14 | How team was organized: Individual, so none |
| 15 | What you might do differently if you did the project again:  The main thing I would’ve improved would be allocating more time for testing runs. Simulations take a while to run, when I ran a simulation with a target in the millions, it took several hours for a single combination to be found. If I were to do this again, I would try to optimize my code better or adjust the randomizer values to run big enough numbers, but not too big that they cause my computer to lag/take an abnormal amount of time to test. Additionally, I would’ve adjusted the capacity values and variety of coins so that I would have more cases where some cases with really large capacities had no solution |
| 16 | Any additional material: N/A |

