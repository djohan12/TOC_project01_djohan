# Project 1 Teamwork djohan-djohan

# Version 1 9/11/24

| 1 | Team Name:djohan |
| :---: | ----- |
| 2 | Individual name: Daniel Johan |
| 3 | Individual netid: djohan |
| 4 | Other team members names and netids: N/A |
| 5 | Link to github repository: https://github.com/djohan12/TOC\_project01\_djohan |
| 6 | Overall project attempted, with sub-projects: Knapsack Problem \- An equivalent of DumbSAT for a solver that returns a coin combination that works |
| 7 | List of included files (if you have many files of a certain type, such as test files of different sizes, list just the folder): (Add more rows as necessary) File/folder Name File Contents and Use Code Files coinsGenerator\_djohan.py Python script that generates a random target, a random set of coin values, and a random capacity of coins that can be put into the knapsack. For example if the capacity is set to 4, you can only make a combination of coins consisting of at most 4 coins. knapsackCSVGenerator\_djohan.py Takes the input file from the coinsGenerator function and computes the runtime and combination of coins that meets the constraints specified in each scenario. The output is stored in a csv file that the user can specify. knapsackSolverTest\_djohan.py Testing script to see if the input from a tester file matches the expected outcome. If the program determines that it’s possible to create a solution from the given parameters, it checks if there was a possible combination from the tester file, and returns true if there was. If there isn’t a possible combination, it just checks that the output combination is empty or Null. Test Files tester\_djohan.txt The tester file consists of 30 test scenarios with 10 of each size problem. Each line in the tester file represents a test case where its parameters are separated by colons and formatted like this: \[Target: Capacity:Coin Values:Possible Combination (if there isn’t a possible combination it is set to 0)\]. When the tester runs, it sees if it can form a proper combination based on the first three parameters, and if it is possible, it double checks that the sum of the combination is equal to the target. Otherwise if the combination in the test scenario is None, it checks if the combination created is also Null. knapsackSolverData\_djohan.txt/knapsackSolverOutput\_djohan.csv These were early tests to see how well my CSV generator worked. For these, I ran the coin generator to make an input of 500 small, medium, and large cases, and ran that file through the knapsack solver to see if it produced a proper csv that recorded the input parameters, the time it took to run, and the combination if it was possible. ProjectInput\_djohan.txt This is the final input file that I used when collecting the time data. It consists of about 5000 possible input cases and then goes through the CSV generator to determine whether it is possible to create a combination of coins and record the amount of time it took to compute the combination. Output Files ProjectData\_djohan.csv Output file of running knapsackCSVGenerator on the ProjectInput\_djohan.txt file (Note: Some of the values in the input file got overwritten because I forgot to set the write flag to append instead of write, so that’s why the number of inputs doesn’t line up with the number of outputs). Plots (as needed) KnapsackPlots\&Analysis\_djohan.pdf 4 page pdf encompassing the data analysis process and patterns found in the data as well as 6 plots of the data. The graphs show the three different independent variables(Target size, Knapsack Capacity, and Number of Different Coins), and each of these variables has two graphs showing the worst case scenario and the overall data.  |
| 8 | Individual Student time (in hours) to complete: 30 hours |
| 9 | Your specific activities and responsibilities:  Implementing a timed recursive algorithm that would brute force the possible combination of coins that could reach a target value without exceeding the capacity of the knapsack. Creating a test script that produced a random number of coin values, target, and capacity that the knapsack solver program would read in and solve. Processing the data by writing to a csv and plotting data using excel, and writing up all the reports and explanations. |
| 10 | What was personally learned (topic, programming, algorithms):  The main technical skills that I learned from this project was the use of recursion to implement a backtracking algorithm. When I first started the project, I already knew that the best way to solve this problem would be some recursive method, so I decided to start my program like that. I had a couple recursion issues where it would recurse infinitely or stop suddenly, but working through the bugs in this project showed me the proper way of implementing backtracking algorithms in general, not just for SAT style problems |
| 11 | How team was organized, and what might be improved:  All work was self–organized, but the main things I would’ve improved would be allocating more time for testing runs. Simulations take a while to run, when I ran a simulation with a target in the millions, it took several hours for a single combination to be found. If I were to do this again, I would try to optimize my code better or adjust the randomizer values to run big enough numbers, but not too big that they cause my computer to lag/take an abnormal amount of time to test. |
| 12 | Any additional material: N/A |

